#include "opaque_test_driver.h"

#include <string.h>
#include <ctype.h>

/* Parameter validation macros */
#define OPQTD_VALIDATE_RET( cond ) \
    MBEDTLS_INTERNAL_VALIDATE_RET( cond, PSA_ERROR_INVALID_ARGUMENT )
#define OPQTD_VALIDATE( cond ) \
    MBEDTLS_INTERNAL_VALIDATE( cond )


static void rot13(const uint8_t *in, size_t len, uint8_t *out)
{
  char c;
  while (len--) {
     c = (char)*in;
     *out = isalpha(c) ? tolower(c) < 'n' ? c+13 : c-13 : c;
     in++;
     out++;
  }
}

psa_status_t opaque_test_driver_import_key(const psa_key_attributes_t *attributes,
                                           const uint8_t *in_key,
                                           size_t        in_key_len,
                                           uint8_t       *out_key,
                                           size_t        out_key_bufsize,
                                           size_t        *out_key_len)
{
  OPQTD_VALIDATE_RET(attributes  != NULL);
  OPQTD_VALIDATE_RET(in_key      != NULL);
  OPQTD_VALIDATE_RET(out_key     != NULL);
  OPQTD_VALIDATE_RET(out_key_len != NULL);

  if (psa_get_key_type(attributes) != PSA_KEY_TYPE_AES) {
    return PSA_ERROR_NOT_SUPPORTED;
  }

  if ((psa_get_key_bits(attributes) != 128)          // AES-128
      && (psa_get_key_bits(attributes) != 192)       // AES-192
      && (psa_get_key_bits(attributes) != 256)) {    // AES-256
    return PSA_ERROR_NOT_SUPPORTED;
  }

  if (psa_get_key_bits(attributes) != PSA_BYTES_TO_BITS(in_key_len)) {
    return PSA_ERROR_INVALID_ARGUMENT;
  }

  if (strlen(OPAQUE_TEST_DRIVER_KEYHEADER) + in_key_len > out_key_bufsize) {
    return PSA_ERROR_BUFFER_TOO_SMALL;
  }

  strcpy((char*)out_key, OPAQUE_TEST_DRIVER_KEYHEADER);

  // Obscure key slightly.
  rot13(in_key, in_key_len, out_key + strlen(OPAQUE_TEST_DRIVER_KEYHEADER));

  *out_key_len = in_key_len + strlen(OPAQUE_TEST_DRIVER_KEYHEADER);

  return PSA_SUCCESS;
}
