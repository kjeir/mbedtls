/* BEGIN_HEADER */
#include "wrapper_opaque_driver.h"
#include <ctype.h>
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_TEST_OPAQUE_DRIVER
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void opaque_driver_bad_param()
{
  #define OPQ_BUFSIZE (64U + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE)
  size_t out_key_len;
  uint8_t in_key[16];
  psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;
  uint8_t out_key[OPQ_BUFSIZE];

  TEST_ASSERT(PSA_SUCCESS == psa_crypto_init());

  psa_set_key_type(&attr, PSA_KEY_TYPE_AES);
  psa_set_key_bits(&attr, 128);

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_import_key(&attr,
                                                      in_key,
                                                      16,
                                                      out_key,
                                                      OPQ_BUFSIZE,
                                                      &out_key_len));
  psa_set_key_type(&attr, PSA_KEY_TYPE_ARC4);
  TEST_ASSERT(PSA_ERROR_NOT_SUPPORTED == opaque_driver_import_key(&attr,
                                                           in_key,
                                                           16,
                                                           out_key,
                                                           OPQ_BUFSIZE,
                                                           &out_key_len));
  psa_set_key_type(&attr, PSA_KEY_TYPE_AES);
  psa_set_key_bits(&attr, 129);
  TEST_ASSERT(PSA_ERROR_NOT_SUPPORTED == opaque_driver_import_key(&attr,
                                                           in_key,
                                                           16,
                                                           out_key,
                                                           OPQ_BUFSIZE,
                                                           &out_key_len));
  psa_set_key_bits(&attr, 128);
  TEST_ASSERT(PSA_ERROR_INVALID_ARGUMENT == opaque_driver_import_key(&attr,
                                                           in_key,
                                                           17,
                                                           out_key,
                                                           OPQ_BUFSIZE,
                                                           &out_key_len));
  TEST_ASSERT(PSA_ERROR_BUFFER_TOO_SMALL == opaque_driver_import_key(&attr,
                                                           in_key,
                                                           16,
                                                           out_key,
                                                           27,
                                                           &out_key_len));

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_generate_key(&attr,
                                                           out_key,
                                                           OPQ_BUFSIZE,
                                                           &out_key_len));
  psa_set_key_bits(&attr, 0);
  TEST_ASSERT(PSA_ERROR_INVALID_ARGUMENT == opaque_driver_generate_key(&attr,
                                                           out_key,
                                                           OPQ_BUFSIZE,
                                                           &out_key_len));
  psa_set_key_bits(&attr, 128);
  psa_set_key_type(&attr, PSA_KEY_TYPE_ARC4);
  TEST_ASSERT(PSA_ERROR_NOT_SUPPORTED == opaque_driver_generate_key(&attr,
                                                           out_key,
                                                           OPQ_BUFSIZE,
                                                           &out_key_len));
  psa_set_key_type(&attr, PSA_KEY_TYPE_AES);
  TEST_ASSERT(PSA_ERROR_BUFFER_TOO_SMALL == opaque_driver_generate_key(&attr,
                                                           out_key,
                                                           27,
                                                           &out_key_len));
  psa_set_key_bits(&attr, 129);
  TEST_ASSERT(PSA_ERROR_NOT_SUPPORTED == opaque_driver_generate_key(&attr,
                                                           out_key,
                                                           OPQ_BUFSIZE,
                                                           &out_key_len));
  psa_set_key_bits(&attr, 128);

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_export_public_key(
                               (uint8_t*)"OPQTDKHEADERHello world 1234",
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_ASSERT(PSA_ERROR_INVALID_ARGUMENT == opaque_driver_export_public_key(
                               (uint8_t*)"OPQTDKHEADERHello world 1234",
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_ASSERT(PSA_ERROR_BUFFER_TOO_SMALL == opaque_driver_export_public_key(
                               (uint8_t*)"OPQTDKHEADERHello world 1234",
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 16,
                               out_key,
                               15,
                               &out_key_len));

  // Check validity of parameter set.
  psa_set_key_usage_flags(&attr, PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH);
  psa_set_key_algorithm(&attr, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
  psa_set_key_type(&attr, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_CURVE_SECP_R1));
  psa_set_key_bits(&attr, 256);
  const uint8_t key[] = {
    0x4F, 0x50, 0x51, 0x54, 0x44, 0x4B, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52,
    0xab, 0x45, 0x43, 0x57, 0x12, 0x64, 0x9c, 0xb3, 0x0b, 0xbd, 0xda, 0xc4, 0x91, 0x97, 0xee, 0xbf,
    0x27, 0x40, 0xff, 0xc7, 0xf8, 0x74, 0xd9, 0x24, 0x4c, 0x34, 0x60, 0xf5, 0x4f, 0x32, 0x2d, 0x3a
  };
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_sign_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_ASSERT(PSA_ERROR_INVALID_ARGUMENT == opaque_driver_sign_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_ASSERT(PSA_ERROR_BUFFER_TOO_SMALL == opaque_driver_sign_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               63,
                               &out_key_len));

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_verify_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               out_key_len));
  TEST_ASSERT(PSA_ERROR_INVALID_ARGUMENT == opaque_driver_verify_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               out_key_len));

exit:
  psa_reset_key_attributes(&attr);
  mbedtls_psa_crypto_free();
  #undef OPQ_BUFSIZE
}
/* END_CASE */

/* BEGIN_CASE */
void opaque_driver_export_public_key(char *in, char *exp_out)
{
  #define OPQ_BUFSIZE (32U + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE)

  size_t out_len;
  uint8_t out[OPQ_BUFSIZE];

  TEST_ASSERT(PSA_SUCCESS == psa_crypto_init());

  TEST_ASSERT(PSA_SUCCESS == opaque_driver_export_public_key(
                               (uint8_t*)in,
                               strlen(in),
                               out,
                               OPQ_BUFSIZE,
                               &out_len));


  mbedtls_fprintf(stdout, "\nExported key,    len:%lu data:", out_len);
  for (unsigned i = 0; i < out_len; i++) {
    if (isalpha(out[i])) {
      mbedtls_fprintf(stdout, "'%c' ", out[i]);
    } else {
      mbedtls_fprintf(stdout, "%02X ", out[i]);
    }
  }
  mbedtls_fprintf(stdout, "\n");

  TEST_ASSERT(0 == mbedtls_test_hexcmp(out,
                                       (uint8_t*)exp_out,
                                       out_len,
                                       strlen(exp_out)));

exit:
  mbedtls_psa_crypto_free();
  #undef OPQ_BUFSIZE
}
/* END_CASE */

/* BEGIN_CASE */
void opaque_driver_generate_key(int type_arg, int bits_arg)
{
  #define OPQ_BUFSIZE (32U + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE)
  size_t key_len = 0;
  uint8_t key[OPQ_BUFSIZE];
  psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;

  TEST_ASSERT(PSA_SUCCESS == psa_crypto_init());

  psa_set_key_type(&attr, type_arg);
  psa_set_key_bits(&attr, bits_arg);

  TEST_ASSERT(PSA_SUCCESS == opaque_driver_generate_key(&attr,
                                                        key,
                                                        OPQ_BUFSIZE,
                                                        &key_len));

  mbedtls_fprintf(stdout, "\nGenerated key,   len:%lu data:", key_len);
  for (unsigned i = 0; i < key_len; i++) {
    if (isalpha(key[i])) {
      mbedtls_fprintf(stdout, "'%c' ", key[i]);
    } else {
      mbedtls_fprintf(stdout, "%02X ", key[i]);
    }
  }
  mbedtls_fprintf(stdout, "\n");

exit:
  psa_reset_key_attributes(&attr);
  mbedtls_psa_crypto_free();
  #undef OPQ_BUFSIZE
}
/* END_CASE */

/* BEGIN_CASE */
void opaque_driver_import_key(char *key_material)
{
  #define OPQ_BUFSIZE (32U + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE)
  size_t out_key_len = 0;
  psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;
  uint8_t out_key1[OPQ_BUFSIZE + 1];
  uint8_t out_key2[OPQ_BUFSIZE + 1];

  TEST_ASSERT(PSA_SUCCESS == psa_crypto_init());

  // --- Figure out if we should set usage & alg attributes ? ---
  // psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
  // psa_set_key_algorithm(&attributes, alg);

  psa_set_key_type(&attr, PSA_KEY_TYPE_AES);
  psa_set_key_bits(&attr, PSA_BYTES_TO_BITS(strlen(key_material)));

  TEST_ASSERT(strlen(key_material) <= 32);
  mbedtls_fprintf(stdout, "\nInput key,       len:%lu data:'%s'\n", strlen(key_material), key_material);

  // Import key.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_import_key(&attr,
                                                      (uint8_t*)key_material,
                                                      strlen(key_material),
                                                      out_key1,
                                                      OPQ_BUFSIZE + 1,
                                                      &out_key_len));

  TEST_ASSERT(strlen(key_material) + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE == out_key_len);
  out_key1[out_key_len] = '\0';
  mbedtls_fprintf(stdout, "Imported key,    len:%lu data:'%s'\n", strlen((char*)out_key1), out_key1);

  // Import the "imported" key (less key header).
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_import_key(&attr,
                                                      out_key1 + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE,
                                                      strlen((char*)out_key1 + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE),
                                                      out_key2,
                                                      OPQ_BUFSIZE + 1,
                                                      &out_key_len));

  TEST_ASSERT(strlen((char*)out_key1) == out_key_len);
  out_key2[out_key_len] = '\0';
  mbedtls_fprintf(stdout, "Re-imported key, len:%lu data:'%s'\n", strlen((char*)out_key2), out_key2);

  // The keys should be equal when ignoring key header.
  TEST_ASSERT(0 == mbedtls_test_hexcmp((uint8_t*)key_material,
                                       out_key2 + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE,
                                       strlen(key_material),
                                       strlen((char*)out_key2 + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE)));

exit:
  psa_reset_key_attributes(&attr);
  mbedtls_psa_crypto_free();
  #undef OPQ_BUFSIZE
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_CHECK_PARAMS:!MBEDTLS_PARAM_FAILED_ALT */
void opaque_driver_invalid_param()
{
  #define OPQ_BUFSIZE (64U + OPAQUE_TEST_DRIVER_KEYHEADER_SIZE)
  size_t out_key_len;
  uint8_t in_key[16];
  psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;
  uint8_t out_key[OPQ_BUFSIZE];

  TEST_ASSERT(PSA_SUCCESS == psa_crypto_init());

  psa_set_key_type(&attr, PSA_KEY_TYPE_AES);
  psa_set_key_bits(&attr, 128);

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_import_key(&attr,
                                                      in_key,
                                                      16,
                                                      out_key,
                                                      OPQ_BUFSIZE,
                                                      &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_import_key(NULL,
                                                  in_key,
                                                  16,
                                                  out_key,
                                                  OPQ_BUFSIZE,
                                                  &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_import_key(&attr,
                                                  NULL,
                                                  16,
                                                  out_key,
                                                  OPQ_BUFSIZE,
                                                  &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_import_key(&attr,
                                                  in_key,
                                                  16,
                                                  NULL,
                                                  OPQ_BUFSIZE,
                                                  &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_import_key(&attr,
                                                  in_key,
                                                  16,
                                                  out_key,
                                                  OPQ_BUFSIZE,
                                                  NULL));

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_generate_key(&attr,
                                                       out_key,
                                                       OPQ_BUFSIZE,
                                                       &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_generate_key(NULL,
                                                       out_key,
                                                       OPQ_BUFSIZE,
                                                       &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_generate_key(&attr,
                                                       NULL,
                                                       OPQ_BUFSIZE,
                                                       &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_generate_key(&attr,
                                                       out_key,
                                                       OPQ_BUFSIZE,
                                                       NULL));

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_export_public_key(
                               (uint8_t*)"OPQTDKHEADERHello world 1234",
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_export_public_key(
                               NULL,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_export_public_key(
                               (uint8_t*)"OPQTDKHEADERHello world 1234",
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 16,
                               NULL,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_export_public_key(
                               (uint8_t*)"OPQTDKHEADERHello world 1234",
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 16,
                               out_key,
                               OPQ_BUFSIZE,
                               NULL));

  // Check validity of parameter set.
  psa_set_key_usage_flags(&attr, PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH);
  psa_set_key_algorithm(&attr, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
  psa_set_key_type(&attr, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_CURVE_SECP_R1));
  psa_set_key_bits(&attr, 256);
  const uint8_t key[] = {
    0x4F, 0x50, 0x51, 0x54, 0x44, 0x4B, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52,
    0xab, 0x45, 0x43, 0x57, 0x12, 0x64, 0x9c, 0xb3, 0x0b, 0xbd, 0xda, 0xc4, 0x91, 0x97, 0xee, 0xbf,
    0x27, 0x40, 0xff, 0xc7, 0xf8, 0x74, 0xd9, 0x24, 0x4c, 0x34, 0x60, 0xf5, 0x4f, 0x32, 0x2d, 0x3a
  };
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_sign_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_sign_hash(
                               NULL,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_sign_hash(
                               &attr,
                               NULL,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_sign_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               NULL,
                               16,
                               out_key,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_sign_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               NULL,
                               OPQ_BUFSIZE,
                               &out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_sign_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               OPQ_BUFSIZE,
                               NULL));

  // Check validity of parameter set.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_verify_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_verify_hash(
                               NULL,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_verify_hash(
                               &attr,
                               NULL,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               out_key,
                               out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_verify_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               NULL,
                               16,
                               out_key,
                               out_key_len));
  TEST_INVALID_PARAM_RET(PSA_ERROR_INVALID_ARGUMENT,
                         opaque_driver_verify_hash(
                               &attr,
                               key,
                               OPAQUE_TEST_DRIVER_KEYHEADER_SIZE + 32,
                               PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                               in_key,
                               16,
                               NULL,
                               out_key_len));

exit:
  psa_reset_key_attributes(&attr);
  mbedtls_psa_crypto_free();
  #undef OPQ_BUFSIZE
}
/* END_CASE */

/* BEGIN_CASE */
void opaque_driver_sign_verify(int key_type_arg, data_t *key_data,
                                    int alg_arg, data_t *input_data)

{
  #define OPQ_BUFSIZE 128U
  size_t key_bits;
  uint8_t sign[OPQ_BUFSIZE];
  size_t sign_size;
  size_t sign_length = 0;
  psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;

  TEST_ASSERT(PSA_SUCCESS == psa_crypto_init());

  psa_set_key_usage_flags(&attr, PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH);
  psa_set_key_algorithm(&attr, alg_arg);
  psa_set_key_type(&attr, key_type_arg);
  psa_set_key_bits(&attr, PSA_BYTES_TO_BITS(key_data->len - OPAQUE_TEST_DRIVER_KEYHEADER_SIZE));

  // Sign the data with the given key.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_sign_hash(&attr,
                                                     key_data->x,
                                                     key_data->len,
                                                     alg_arg,
                                                     input_data->x,
                                                     input_data->len,
                                                     sign,
                                                     OPQ_BUFSIZE,
                                                     &sign_length));

  key_bits = psa_get_key_bits(&attr);
  sign_size = PSA_SIGN_OUTPUT_SIZE(key_type_arg, key_bits, alg_arg);

  mbedtls_fprintf(stdout, "\nKey attribs,     key-bits:%lu, sign-size:%lu, sign-len:%lu",
                  key_bits, sign_size, sign_length);

  // Check that the signature length looks sensible.
  TEST_ASSERT(sign_size != 0);
  TEST_ASSERT(sign_size <= PSA_SIGNATURE_MAX_SIZE);
  TEST_ASSERT(sign_size <= OPQ_BUFSIZE);
  TEST_ASSERT(sign_length <= sign_size);
  TEST_ASSERT(sign_length > 0);

  mbedtls_fprintf(stdout, "\nSignature,       len:%lu data:", sign_length);
  for (unsigned i = 0; i < sign_length; i++) {
    mbedtls_fprintf(stdout, "%02X ", sign[i]);
  }
  mbedtls_fprintf(stdout, "\n");

  // Verify that the signature is correct.
  TEST_ASSERT(PSA_SUCCESS == opaque_driver_verify_hash(&attr,
                                                       key_data->x,
                                                       key_data->len,
                                                       alg_arg,
                                                       input_data->x,
                                                       input_data->len,
                                                       sign,
                                                       sign_length));

  if (input_data->len != 0) {
    /* Flip a bit in the input and verify that the signature is now
     * detected as invalid. Flip a bit at the beginning, not at the end,
     * because ECDSA may ignore the last few bits of the input. */
    input_data->x[0] ^= 1;
    TEST_ASSERT(PSA_ERROR_INVALID_SIGNATURE == opaque_driver_verify_hash(
                                                 &attr,
                                                 key_data->x,
                                                 key_data->len,
                                                 alg_arg,
                                                 input_data->x,
                                                 input_data->len,
                                                 sign,
                                                 sign_length));
  }

exit:
  psa_reset_key_attributes(&attr);
  mbedtls_psa_crypto_free();
  #undef OPQ_BUFSIZE
}
/* END_CASE */
